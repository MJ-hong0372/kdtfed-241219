// 자바스크립트 코드가 작성 혹은 생성 될 시 => 컴퓨터 메모리 공간 => 객체를 생성 => 실행 컨텍스트 = execution context 가 생성 됨

// execution context : 개발자가 현재 작성 혹은 생성 변수(식별자)가 어떤 것이 있는지, 실행 시켜야 하는 함수는 무엇인지 등등의 정보를 저장해놓고 있음!!
// execution context => 어떤 코드를 먼저 실행해야 하는가에 대한 우선 순위를 결정하기 위한 목적

// 컴퓨터 > 자바스크립트가 어떤 곳에서 어떤 방식으로 실행되는지를 이해해야 함.

// 컴퓨터 안에 공간을 생성 > stack => 쌓다 // 스택과 반대되는 것 => Queue : 대기열
//  엘리베이터 => 스택 구조 <-> 큐(queue) => 놀이동산 구조.
// 10층에서 먼저 기다리고 있던 사람이 먼저 엘리베이터 탑승
// 먼저 탄 사람은 엘리베이터 뒤쪽에 위치 > 가장 나중에 엘리베이터에 탑승 한 사람이 가장 먼저 내림.
// stack이 생기면 가장 먼저 생성된 데이터가 뒤에 있고 차근차근 그 위에 새 데이터가 쌓임. 위에부터 순서대로 처리됨.
// 스텍은 입구와 출구가 하나다.
// Queue  입구와 출구가 따로다. 요구가 온 걸 먼저 처리함

// call stack : 자바스크립트가 명령문을 처리하는 공간

// 저장되는 정보들 종류

// 01. VariableEnvironment : 환경변수 // 현재 실행 컨텍스트 내 변수명, 함수정보, 실행 컨텍스트 내 특정 함수가 호출 혹은 실행되는 순간 해당 함수를 스냅샷의 형태로 저장 해 둠.
// Snapshot : 일시정시 사진

// 함수를 호출하면 함수의 초기값인 스냅샷 형태로 되어있고

// Lexical : 사전적인 = "사전"답사

// 02. LexicalEnvironment : 전처리 환경. 초기에는 VariableEnvironment 와 동일한 값으로 시작하지만, 특정 함수를 호출하면 해당 함수가 실시간 처리를 하고 있는 상태를 바로 반영을 해줌.
// environmentRecord => 현재 실행하고자 하는 코드들 내부에 저장되어 있는 정보값을 가지고 있음.
// outer-EnviromentReference : 현재 실항하고자 하는 코드들이 외부에 영향을 받고 있는지, 받고 있다면 누구의 영향을 받는지를 확인 할 수 있는 정보값을 가지고 있음.

// 03. ThisBinding : 현재 변수 \\ 식별자가 가리켜야 하는 대상 객체가 누구인지에 대한 정보값을 가지고 있음.

// 자바 스크립트가 실행되면 3개의 값이 생성 된다는 것을 전재로 깔고 간다.

/* let a = 1;
function outer() {
  function inner() {
    console.log(a);
    a = 3;
  }
  inner();
  console.log(a);
}

outer();
console.log(a); */

// 1, 3, 3 이 나옴.
// call stack 안에 차곡차곡 쌓인다. 먼저 실행 컨테스트부터 쌓임. outer가 먼저 쌓임. 그래서 아우터를 읽으러 감. 이너를 두고, 아우터 해결 전에 이너 실행문이 있는 걸 보고 이너를 실행함. 이너에 가서 a를 먼저 호출한걸 보고 출력하는데 이건 전역변수의 1임. 그 다음 재할당이 일어나서 a는 3이 됨. 그 다음 이너 실행을 끝내고 inner();아래의 a를 찾아옴. 그 다음 맨 아래 console.log(a);을 보고 마지막으로 3을 출력함.

// VariableEnvironment은 스냅샷으로 지금 화면을 가지고 있고. 실시간으로 LexicalEnvironment가 실행되며 environmentRecord와 outer-EnviromentReference가 실행되며 a가 어떤 a인지 구별하고 있음.

// 슬라이드 제작 시 아주 중요한 개념.
// 자동 슬라이드 => 특정시간마다 슬라이드가 계속 멈춰라 => 함수 / 마우스를 가져다 대면 멈춰라 => 함수 => 두 함수가 충돌하게 됨. call stack 개념이 없기 때문에 그럼. 스텍에 어떤 함수가 먼저 쌓일지를 결정 해서 코딩 해야 함.

/*function a() {
  let x = 1;
  console.log(x);
  x; // 값을 주지 않았다는 것은 참조값을 다시 찾아왔다는 것. 보통 null 이나 undifind가 나올거라고 추측함.
  console.log(x);
  x = 2;
  console.log(x);
}
a();*/

// 1 1 2 로 불러옴
// x; console.log(x); 가 null 이나 undifind가 아닌 이유는 호이스팅 때문임.
// 호이스팅 = 우물 = 무언가는 끌어올린다 =
// 코드를 쓰는 순간 실행 컨테스트가 실행되며 호이스팅이 작동되며 식별자를 끌어온다. (식별자의 값은 끌어오지 않음.)
// 호이스팅이 작동되면 위 코드를 하단과 같이 보게 됨.

/* function a() {
  let x;
  x;

  x = 1;
  console.log(x);
  console.log(x);
  x = 2;
  console.log(x);
}
*/

//
//

/* function a() {
  console.log(b);
  let b = "bbb"; // 에러뜸. 호출 후 선언이 되어서 에러가 뜨는 것.
}
a(); */

/* function a() {
  console.log(b);
  b = "bbb"; // b is not defined => b에 선언이 되어 있지 않다는 문구가 뜸
}
a(); */

function a() {
  console.log(b);
  b = "bbb";

  console.log(b);
  function b() {}

  console.log(b);
}
a();

// 실행 컨테스트가 실행 후 식별자(변수명)을 위로 끌어올림. b라는 변수를 끌어올림. 그런데 b는 let,var,const로 선언 한 적이 없음.
// 간혹, 전역변수 이후에 특정 함수 안에 있는 연산작업을 통한 결과값을 변수가 가지고 와서 다시 전역변수로 가지고 가는 경우가 있다. let, var, const를 쓰지도 않고 변수를 선언을 하게 되는 것. But 흔한 방법이 아니고 좋은 방법은 아님. 초 우주적 변수가 됨. 어떤 영향을 받지 않는 변수가 되어버림. 부득이한 경우 아닌 경우에만 만들어야 함. 다른 요소들에 어떤 영향을 줄 지 알 수가 없다.

/* function a() {
  let b;
  b = function b() {}

  console.log(b);
  b = "bbb";

  console.log(b);
  console.log(b);
}
a(); */
// b를 먼저 호이스팅 후, 이후 함수를 함수자체를 위로 가져와버린다. 이때 함수명인 b를 변수명으로 선언해버린다. 위의 let b와 함수명이 겹쳐서  // ƒ b() {}, bbb, bbb 라고 호출이 됨.
