* 2025-01-14 수업필기

//스크립트를 잘 하고 싶으면 한글로 지금 내가 제어 하고자 하는 내용이 무엇인지 부터 작성해보기!!

//한글로 지금 내가 제어 하고자 하는 내용이 무엇인지 부터 작성해보기!!

//논리적으로!!

// 내가 현재 구현하고자 하는 기능을 대략적이지만 말로 표현하지 못한다면, 100% 코딩은 불가하다!!!

// 자바스크립트를 어려워 하지 말고 내가 지금 우엇을 해야 할지 한글로 써본다.

// 8개의 면들을 가지고 모션 제어

// 01. 8개의 face를 대상으로 모션을 제어할 것

// -> 컴퓨터에게 무엇이 8개의 face인지 부터 알려주기

// --> 8개의 face를 어딘가에 담아서 컴퓨터에게 "이게 8개의 face야!"라고 알려줘야 함

// 그 어딘가에 담고자 하는 그릇 => 변수라고 부름 => 변수를 생성해야 컴퓨터가 이해 함

// 02. 해당 모션 : 각각의 face에 마우스를 올리면 회전이 멈춤

// 03. 해당 모션 : 각각의 face에서 마우스가 떠나가면 회전이 정상적으로 진행


---------------------------------------------------------------------------------------------

const // 변수선언

const circle // circle이라고 변수명 선언
document // 문서에서
.querySelector // 기존 선택자

const circle = document.querySelector("#circle");
기존 html 파일에 있는 class 라고 알려줌

console.log(circle);
실제로 있는지 찾아오라는 명령어 => 관리자 모드에서 확인한다. 확인 후 지운다.

* 반복문을 쓰려면 대상부터 찾아와야 함

const articles = circle.querySelectorAll("article");
복수의 객체를 찾아오겠다

console.log(articles);
적용되었는지 확인하는 명령어 => 관리자 모드에서 새로고침 후 확인 . 확인 후 지운다.

---------------------------------------------------------------------------------------------

articles.forEach((article) => {
  article.addEventListener("mouseenter", () => {
    circle.style.animationPlayState = "paused";
  });
});

articles.forEach((임자값을 할당) => {
  대상자.할당된이벤트를들을대상자("이벤트종류", () => {
  특정대상.CSS시트확인해줘.애니메이션부여기능 = "멈춰";
  });
});
=> 화살표함수 // 
() 함수 안에 함수로 들어오면 콜백 함수라고 부름


---------------------------------------------------------------------------------------------

flex
grid
scss
tailwind

수업 후 취업 분야

UI/UX
Publisher
Frontend

---------------------------------------------------------------------------------------------

flex : flexible(유연)한 style을 기존 CSS 스타일 속성보다 보다 쉽고, 효율적으로 적용하도록 하기 위해서 만들어진 프레임 요소

- 레이아웃 정렬
[기존 방식]
position: absolute;
top: 50%;
left: 50%; 
transform: translate(-50%, -50%);

- 위치 속성을 적용하고 싶은 대상의 부모요소에게 항상 & 반드시 display : flex; 를 준다. 

- display : flex; 라는 위치속성을 부여하는 순간, 자동으로 중심축 & 교차축이 생성된다. 
 
- 중심축 & 교차축 기준
- 중심축 : 가로 = row
- 교차축 : 세로 = column

- justify-content : center; 
justify (중심축을 기준으로 조절하겠다) / content : center; 대상요소를 가운데로.
justify-content : center; // flex-start / flex-end => 좌우 끝 정렬

- align-items : center; // 교차축을 기준으로 정렬하겠다. // 
height 값이 없으면 적용이 안됨 - flex가 height를 인지하지 못해서 교차축을 계산 못함. height: 100vh; - 생략 불가 / width: 100%; - 생략 가능
align-items : center; // flex-start / flex-end => 상하 끝 정렬

- flex를 편하게 주려면 여러 요소를 div로 묶어서 이동시키는게 편함

- BUT 여러 개의 div(자식요소)가 있으면 생기는 현상
- display : flex; 라는 위치속성을 부여하는 순간 부모 밑에 모든 자식요소들이 가로로 한 줄 정렬이 됨

- flex-direction로 가로 세로 정렬을 정할 수 있음
- flex-direction:row;가 기본값 // flex-direction:column이 중심축이 세로가 됨
- flex-direction:column가 되면 중심축이 세로가 되기에 justify-content: center;는 세로로 정렬이 됨 (가로정렬이 아님. 중심축 기준 가운데 정렬임)
- flex-direction:column가 되면 교차축이 세로가 되기에 align-items: center; 도 가로로 정렬이 됨 (세로 정렬이 아님. )

- 자식요소에 높이값을 주지 않았으나, 부모 요소의 높이값을 상속 받음
- 그러나 요소 자체에 값을 별도로 주면 상속 값을 거부하고, 본인을 최우선시 함

----------------------------------------

- justify-content: space-between; A와 C를 양 끝으로 보내고 정 가운데에 B를 둔다.
공간과 공간 사이를 자동 정렬

- justify-content: space-around; 맨 끝 공간과 A와 공간을 a-1로 하면 모든 공간을 a-1로 동일하게 부여함. a-1<div>a-1,a-1<div>a-1,a-1<div>a-1 //양 옆에 공간을 조금 떨어트려야 할 경우.

- justify-content: space-evenly;  a-1<div>a-1<div>a-1<div>a-1 //양 옆에 공간을 많이 떨어트려야 할 경우. 

----------------------------------------

- align-items: stretch; 기본 설정 값. 부모요소의 높이 값을 최대로 가져간다. 

---------------------------------------------------------------------------------------------

- flex 설정을 주면 자식요소들이 너비를 기본으로 보장해주지 않는 속성이 있음
- 자식요소 너비를 줘도 화면을 줄이면 너비가 줄어버림
- flex-wrap: wrap; =>부모요소 아래 자식 요소의 너비를 보장하기 위해서 주는 속성  <-> nowrap (flex의 기본 설정 속성)

----------------------------------------

- flex-flow : (flex-direction) (flex-wrap); 축약형
- ex) flex-flow : column wrap; 처럼 씀
> 상기 두가지의 요소를 한번에 사용할 수 있는 축약형

----------------------------------------

- flex-wrap: wrap; =>를 줬을 때 행 바꿈이 자동으로 됨.
align-items: center; -->가운데로 모이지만, 행이 분리 되어 있는 상태로 개별적으로 가운데로 모임 

align-content: center; --> 자식요소들을 하나의 그룹으로 인식한 후 교차정렬을 실행시킴 // center; // flex-start / flex-end // space-between // space-around //space-evenly 

----------------------------------------

- flex-grow // 부모요소가 가지고 있는 전체 너비값을 기준으로 그 밑에 있는 자식 요소들의 너비를 몇분의 몇으로 (1/n)로 정의해서 적용하고 싶은 경우에 사용
flex-grow: 1; => 남은 공간을 1, 즉 100%를 다 가져가라.

- 3개의 div가 있다면 // 각각의 div1은 1 => 1/6만큼 가져감 /  div2은 2 => 2/6만큼 가져감 /  div3은 3  => 1/2 만큼 가져감// 1+2+3 = 6 을 기준으로 나눠라.
-> 화면이 줄어들면 flex-wrap: no-wrap; 값을 기본으로 가져가게 됨


- flex-shrink // 부모요소가 가지고 있는 전체 너비값을 기준으로 그 밑에 있는 자식 요소들의 너비를 줄임. 비율을 적용하고 싶은 경우 사용.
shrink(줄이다, 압축하다) flex-shrink: 0;를 주면 부모 요소 너비안에 배열되어야 하는 flex의 값을 무시함 (flex-wrap: wrap;은 자식의 너비를 보호하지만 행을 바꾸게 됨)

- 3개의 div가 있다면 // 각각의 div1은 1 => 1/4만큼 가져감 /  div2은 2 => 2/4만큼 가져감 /  div3은 3  => 1/4 만큼 가져감// 1+2+1 = 4 을 기준으로 줄여라. 숫자가 클수록 더 줄여라. // flex-grow 와 정반대


- flex-basis // 부모요소 아래 있는 자식 요소들의 기본 너비 값을 어떻게 보장하고 할지 결정할 때 사용 함. = width와 거의 유사한 속성

flex : (flex-grow) (flex-shrink) (flex-basis);
flex : (flex-grow);가 기본값

----------------------------------------

gap: 30px; 아이템 사이에 간격을 줄 때 사용.
margin은 상하좌우를 주는 것 // gap은 아이템들 사이에만 주는 여백


align-self: flex-end; <-- 이 요소만 시작점을 바꿈. 


---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------

* 오후 실습 시작


* 가상클래스
> 평상시에는 아무런 영향이 없음
> 특정 이벤트 조건이 부합되면 이후부터 해당 클래스가 적용 됨

-----------------------------------------------

스크롤은 브라우저가 가지고 있음

window.addEventListener("scroll", () => {
  alert("안녕! 나는 스크롤이야!");
});
// 브라우저가 가지고 있는 내장객체 

-----------------------------------------------


window.addEventListener("scroll", () => {
 if(조건문) {
  조건문이 참:true이면 실행 
 }
});
















